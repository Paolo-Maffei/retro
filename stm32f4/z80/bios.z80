; Minimal CPM 2.2 BIOS -jcw, 2018-11-10

VERS:   equ 01h

; Memory map -------------------------------------------------------------------

CCP:    equ 0E400h
BDOS:   equ CCP + 0806h
BIOS:   equ CCP + 1600h

; Low memory -------------------------------------------------------------------

iobyte: equ 03h     ; Intel standard I/O definition byte
usrdrv: equ 04h     ; Current user number and drive
tpabuf: equ 0080h   ; Default I/O buffer and command line storage

         org BIOS

; BIOS jump table --------------------------------------------------------------

        jp boot     ; 0 Initialize
wboote: jp wboot    ; 1 Warm boot
        jp conist   ; 2 Console status
        jp conin    ; 3 Console input
        jp conout   ; 4 Console OUTput
        jp list     ; 5 List OUTput
        jp punch    ; 6 punch OUTput
        jp reader   ; 7 Reader input
        jp home     ; 8 Home disk
        jp seldsk   ; 9 Select disk
        jp settrk   ; 10 Select track
        jp setsec   ; 11 Select sector
        jp setdma   ; 12 Set DMA ADDress
        jp read     ; 13 Read 128 bytes
        jp write    ; 14 Write 128 bytes
        jp listst   ; 15 List status
        jp sectrn   ; 16 Sector translate

; Disk Parameter Headers -------------------------------------------------------

dpbase: dw 0,0,0,0,dirbuf,dpb,0,alv0
        dw 0,0,0,0,dirbuf,dpb,0,alv1
        dw 0,0,0,0,dirbuf,dpb,0,alv2

dpb:    dw 52  ; SPT - sectors per track
        db 3   ; BSH - block shift factor
        db 7   ; BLM - block mask
        db 0   ; EXM - Extent mask
        dw 248 ; DSM - Storage size (blocks - 1)
        dw 63  ; DRM - Number of directory entries - 1
        db 192 ; AL0 - 1 bit set per directory block
        db 0   ; AL1 - ... 8 more bits
        dw 0   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
        dw 1   ; OFF - Reserved tracks

; Cold boot --------------------------------------------------------------------

boot:   di
        ld sp,0100h

        ld de,dirbuf
        in a,(3)                ; display greeting

        xor a
        ld (iobyte),a
        ld (usrdrv),a
        jr gocpm

; Warm boot --------------------------------------------------------------------

wboot:  di
        ld sp,0100h

        ld a,(usrdrv)
        ld b,11                 ; read CCP + BDOS into memory (5.5 KB)
        ld de,2                 ; skip first first 2 blocks on first track
        ld hl,CCP               ; start address
        in a,(4)                ; disk read request

; Common code for cold and warm boot

gocpm:  ld hl,tpabuf            ; Address of BIOS DMA buffer
        ld (dmaadr),hl
        ld a,0C3h               ; Opcode for 'JP'
        ld (00h),a              ; Load at start of RAM
        ld hl,wboote            ; Address of jump for a warm boot
        ld (01h),hl
        ld (05h),a              ; Opcode for 'JP'
        ld hl,BDOS              ; Address of jump for the BDOS
        ld (06h),hl
        ld a,(usrdrv)           ; Save new drive number (0)
        ld c,a                  ; Pass drive number in C
        jp CCP                  ; Start CP/M by jumping to the CCP

; Console I/O ------------------------------------------------------------------

conist: in a,(0)
        ret

conin:  in a,(1)
        ret

conout: in a,(2)
        ret

reader: ld a,1Ah
        ret

; Disk I/O ---------------------------------------------------------------------

seldsk: ld a,c
        cp 3
        jr nc,baddsk
        ld h,0
        ld l,c
        add hl,hl
        add hl,hl
        add hl,hl
        add hl,hl
        ld de,dpbase
        add hl,de
savdsk: ld (sekdsk),a
        ret

baddsk: ld hl,0
        ld a,(usrdrv)
        sub a,c
        ret nz
        ld (usrdrv),a
        jr savdsk

home:   ld bc,0
settrk: ld (sektrk),bc
        ret

setsec: ld hl,seksec
        ld (hl),c
        ret

setdma: ld (dmaadr),bc
        ret

sectrn: ld l,c
        ld h,b
        ret

; Sector Deblocking Algorithms for CP/M 2.0 ------------------------------------

; CP/M to host disk constants
blksize	equ	1024		; CP/M allocation size
hstsiz	equ	512 		; host disk sector size
hstblk	equ	hstsiz/128	; CP/M sectors/host buff
cpmspt	equ	52           	; CP/M sectors/track
secmsk	equ	hstblk-1	; sector mask
secshf	equ	2		; log2(hstblk)

; BDOS constants on entry to write
wrall	equ	0		; write to allocated
wrdir	equ	1		; write to directory
wrual	equ	2		; write to unallocated

; read the selected CP/M sector
read:   xor	a		; these 2 lines are
	ld	(unacnt),a	; a DRI patch
	ld	a,1
	ld	(readop),a	; read operation
	ld	(rsflag),a	; must read data
	ld	a,wrual
	ld	(wrtype),a	; treat as unalloc
	jp	rwoper		; to perform the read

; write the selected CP/M sector
write:
	xor	a		; 0 to accumulator
	ld	(readop),a	; not a read operation
	ld	a,c		; write type in c
	ld	(wrtype),a
	cp	wrual		; write unallocated?
	jp	nz,chkuna	; check for unalloc

; write to unallocated, set parameters
	ld	a,blksize/128	; next unalloc recs
	ld	(unacnt),a
	ld	a,(sekdsk)	; disk to seek
	ld	(unadsk),a	; unadsk = sekdsk
	ld	hl,(sektrk)
	ld	(unatrk),hl	; unatrk = sectrk
	ld	a,(seksec)
	ld	(unasec),a	; unasec = seksec

; check to write to unallocated sector
chkuna:
	ld	a,(unacnt)	; any unalloc remain?
	or	a
	jp	z,alloc		; skip if not

; more unallocated records remain
	dec	a		; unacnt = unacnt-1
	ld	(unacnt),a
	ld	a,(sekdsk)	; same disk?
	ld	hl,unadsk
	cp	(hl)		; sekdsk = unadsk ?
	jp	nz,alloc	; skip if not

; disks are the same
	ld	hl,unatrk
	call	sektrkcmp	; sektrk = unatrk ?
	jp	nz,alloc	; skip if not

; tracks are the same
	ld	a,(seksec)	; same sector ?
	ld	hl,unasec
	cp	(hl)		; seksec = unasec ?
	jp	nz,alloc	; skip if not

; match, move to next sector for future ref
	inc	(hl)		; unasec = unasec+1
	ld	a,(hl)		; end of track ?
	cp	cpmspt		; count CP/M sectors
	jp	c,noovf		; skip if no overflow

; overflow to next track
	ld	(hl),0		; unasec = 0
	ld	hl,(unatrk)
	inc	hl
	ld	(unatrk),hl	; unatrk = unatrk+1

; match found, mark as unnecessary read
noovf:
	xor	a		; 0 to accumulator
	ld	(rsflag),a	; rsflag = 0
	jp	rwoper		; to perform the write

; not an unallocated record, requires pre-read
alloc:
	xor	a		; 0 to accumulator
	ld	(unacnt),a	; unacnt = 0
	inc	a		; 1 to accum
	ld	(rsflag),a	; rsflag = 1

; enter here to perform the read/write
rwoper:
	xor	a		; zero to accum
	ld	(fdcst),a	; no errors (yet)
	ld	a,(seksec)	; compute host sector
	or	a		; carry = 0
	rra			; shift right
	or	a		; carry = 0
	rra			; shift right
	or	a		; carry = 0
	rra			; shift right
	ld	(sekhst),a	; host sector to seek

; active host sector?
	ld	hl,hstact	; host active flag
	ld	a,(hl)
	ld	(hl),1		; always becomes 1
	or	a		; was it already?
	jp	z,filhst	; fill host if not

; host buffer active, same as seek buffer?
	ld	a,(sekdsk)
	ld	hl,hstdsk	; same disk?
	cp	(hl)		; sekdsk = hstdsk ?
	jp	nz,nomatch

; same disk, same track?
	ld	hl,hsttrk
	call	sektrkcmp	; sektrk = hsttrk ?
	jp	nz,nomatch

; same disk, same track, same buffer ?
	ld	a,(sekhst)
	ld	hl,hstsec	; sekhst = hstsec ?
	cp	(hl)
	jp	z,match		; skip if match

; proper disk, but not correct sector
nomatch:
	ld	a,(hstwrt)	; host written?
	or	a
	call	nz,writehst	; clear host buff

; may have to fill the host buffer
filhst:
	ld	a,(sekdsk)
	ld	(hstdsk),a
	ld	hl,(sektrk)
	ld	(hsttrk),hl
	ld	a,(sekhst)
	ld	(hstsec),a
	ld	a,(rsflag)	; need to read?
	or	a
	call	nz,readhst	; yes, if 1
	xor	a		; 0 to accum
	ld	(hstwrt),a	; no pending write

; copy data to or from buffer
match:
	ld	a,(seksec)	; mask buffer number
	and	secmsk		; least significant bits
	ld	l,a		; ready to shift
	ld	h,0		; double count
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
; hl has relative host buffer address
	ld	de,hstbuf
	add	hl,de		; hl = host address
	ex	de,hl		; now in DE
	ld	hl,(dmaadr)	; get/put CP/M data
	ld	b,128		; length of move
	ld	a,(readop)	; which way?
	or	a
	jp	nz,rwmove	; skip if read

; write operation, mark and switch direction
	ld	a,1
	ld	(hstwrt),a	; hstwrt = 1
	ex	de,hl

; B initially 128, DE is source, HL is dest
rwmove:
	ld	a,(de)		; source character
	inc	de
	ld	(hl),a		; to dest
	inc	hl
	dec	b		; loop 128 times
	jp	nz,rwmove

; data has been moved to/from host buffer
	ld	a,(wrtype)	; write type
	cp	wrdir		; to directory?
	ld	a,(fdcst)	; in case of errors
	ret	nz		; no further processing

; clear host buffer for directory write
	or	a		; errors?
	ret	nz		; skip if so
	xor	a		; 0 to accum.
	ld	(hstwrt),a
	call	writehst
	ld	a,(fdcst)
	ret

; HL = .unatrk or .hsttrk, compare with sektrk
sektrkcmp:
	ex	de,hl
	ld	hl,sektrk
	ld	a,(de)		; low byte compare
	cp	(hl)		; same?
	ret	nz		; return if not
; low bytes equal, test high 1s
	inc	de
	inc	hl
	ld	a,(de)
	cp	(hl)		; sets flags
	ret

; hstdsk = host disk #, hsttrk = host track #,
; hstsec = host sect #.  read "hstsiz" bytes
; into hstbuf and return error flag in fdcst.
readhst:
        ld      b,1
        jr      rdwr

; hstdsk = host disk #, hsttrk = host track #,
; hstsec = host sect #.  write "hstsiz" bytes
; from hstbuf and return error flag in fdcst.
writehst:
        ld      b,1+80h
rdwr:   ld      hl,(hsttrk)
        ld      e,l
        ld      d,h
        add     hl,hl ; *2
        add     hl,de ; *3
        add     hl,hl ; *6
        add     hl,hl ; *12
        add     hl,de ; *13
        ld      a,(hstsec)
        ld      e,a
        ld      d,0
        add     hl,de ; 13*trk+sec
	ex	de,hl
        ld      hl,hstbuf
        ld      a,(hstdsk)
        in      a,(4)
        ret

listst:
list:
punch:
        xor a
        ret

; Data area --------------------------------------------------------------------

fdcst:	db	0

dirbuf: db 13,10,'64K CP/M 2.2 (512b)',13,10,0

        org dirbuf+128

; Uninitialized data -----------------------------------------------------------

sekdsk:	ds	1	; seek disk number
sektrk:	ds	2	; seek track number
seksec:	ds	1	; seek sector number

hstdsk:	ds	1	; host disk number
hsttrk:	ds	2	; host track number
hstsec:	ds	1	; host sector number

sekhst:	ds	1	; seek shr secshf
hstact:	ds	1	; host active flag
hstwrt:	ds	1	; host written flag

unacnt:	ds	1	; unalloc rec cnt
unadsk:	ds	1	; last unalloc disk
unatrk:	ds	2	; last unalloc track
unasec:	ds	1	; last unalloc sector

rsflag:	ds	1	; read sector flag
readop:	ds	1	; 1 if read operation
wrtype:	ds	1	; write operation type
dmaadr:	ds	2	; last dma address
hstbuf:	ds	hstsiz	; host buffer


alv0:   ds 32  ; allocation vector 0 (max 256 blocks)
alv1:   ds 32  ; allocation vector 0 (max 256 blocks)
alv2:   ds 32  ; allocation vector 0 (max 256 blocks)

; ------------------------------------------------------------------------------

        end
